<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>CoinDCX Auto Trader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 24px;}
    .row {display:flex; gap:16px; flex-wrap:wrap; align-items:center}
    .card {border:1px solid #ddd; padding:12px 16px; border-radius:8px; min-width:240px}
    pre {background:#f7f7f7; padding:12px; border-radius:8px; max-height:300px; overflow:auto;}
    button {padding:8px 14px; border-radius:6px; border:1px solid #ccc; cursor:pointer}
    .ok{color:#0a0}
    .warn{color:#a60}
    .bad{color:#c00}
  </style>
</head>
<body>
  <h2>CoinDCX Auto Trader</h2>

  <div class="row">
    <button id="btnStart">Start</button>
    <button id="btnStop">Stop</button>
    <span>Status: <b id="lblStatus">Idle</b></span>
    <span>Last: <span id="lblLast">-</span></span>
  </div>

  <div class="row" style="margin-top:12px">
    <div class="card">
      <div>USDT: <b id="lblUSDT">0</b></div>
      <div>Today P&L (USDT): <b id="lblPNLT">0</b></div>
      <div>Yesterday P&L (USDT): <b id="lblPNLY">0</b></div>
      <div>Total P&L (USDT): <b id="lblPNLAll">0</b></div>
    </div>
  </div>

  <h3>Scans (latest 30)</h3>
  <pre id="scanLog"></pre>

  <h3>Trades (latest 10)</h3>
  <pre id="tradeLog"></pre>

  <script>
  // --- simple UI handlers for start/stop ---
  document.getElementById('btnStart').onclick = async () => {
    try { const r = await fetch('/start', {method:'POST'}); console.log('start', await r.json()); } catch(e){}
  };
  document.getElementById('btnStop').onclick = async () => {
    try { const r = await fetch('/stop', {method:'POST'}); console.log('stop', await r.json()); } catch(e){}
  };

  // --- Watchdog + Keepalive ---
  (() => {
    const PING_MS = 60 * 1000;
    const CHECK_MS = 60 * 1000;
    const STALE_SEC = 120;
    const START_RETRY_MS = 10 * 1000;

    let lastStatusEpoch = 0;

    async function safeFetch(url, opts = {}, timeoutMs = 8000) {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      try {
        const res = await fetch(url, { keepalive: true, signal: ctrl.signal, ...opts });
        clearTimeout(t);
        return res;
      } catch (e) {
        clearTimeout(t);
        throw e;
      }
    }

    async function keepAlive() {
      try { await safeFetch('/ping', {}, 4000); } catch (_) {}
    }

    async function startScanner() {
      try {
        const res = await safeFetch('/start', { method: 'POST' }, 6000);
        console.log('[auto-start] result', await res.json());
      } catch (e) {
        console.warn('[auto-start] failed, retrying soon', e);
        setTimeout(startScanner, START_RETRY_MS);
      }
    }

    function renderStatus(data){
      document.getElementById('lblStatus').textContent = data.status || '—';
      document.getElementById('lblLast').textContent = data.last || '—';
      document.getElementById('lblUSDT').textContent = (data.usdt ?? 0).toFixed(2);
      document.getElementById('lblPNLT').textContent = (data.profit_today ?? 0).toFixed(2);
      document.getElementById('lblPNLY').textContent = (data.profit_yesterday ?? 0).toFixed(2);
      document.getElementById('lblPNLAll').textContent = (data.pnl_cumulative ?? 0).toFixed(2);

      const scans = Array.isArray(data.scans) ? data.scans.join('\n') : '';
      const trades = Array.isArray(data.trades) ? data.trades.map(t => JSON.stringify(t)).join('\n') : '';
      document.getElementById('scanLog').textContent = scans;
      document.getElementById('tradeLog').textContent = trades;
    }

    async function checkStatusAndAutostart() {
      try {
        const res = await safeFetch('/status', {}, 8000);
        if (!res.ok) throw new Error('status not ok');
        const data = await res.json();
        renderStatus(data);

        const nowSec = Math.floor(Date.now() / 1000);
        const epoch = Number(data.status_epoch || 0);
        const isIdle = (data.status || '').toLowerCase() !== 'running';
        const isStale = epoch && (nowSec - epoch > STALE_SEC);

        if (isIdle || isStale) {
          console.log('[watchdog] idle/stale detected -> auto-start', { isIdle, isStale, epoch });
          startScanner();
        }
        lastStatusEpoch = epoch || lastStatusEpoch;
      } catch (e) {
        console.warn('[watchdog] status failed; will retry', e);
        setTimeout(startScanner, START_RETRY_MS);
      }
    }

    // initial kicks
    keepAlive();
    checkStatusAndAutostart();
    startScanner();

    // repeaters
    setInterval(keepAlive, PING_MS);
    setInterval(checkStatusAndAutostart, CHECK_MS);

    window.addEventListener('focus', () => {
      keepAlive();
      checkStatusAndAutostart();
    });
  })();
  </script>
</body>
</html>
